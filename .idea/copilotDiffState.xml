<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/inners/use_cases/auth_use_case.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/inners/use_cases/auth_use_case.go" />
              <option name="originalContent" value="package use_cases&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;crypto/rsa&quot;&#10;&#9;&quot;crypto/x509&quot;&#10;&#9;&quot;encoding/pem&quot;&#10;&#9;&quot;social-media-backend-1/internal/inners/models/entities&quot;&#10;&#9;&quot;social-media-backend-1/internal/inners/models/value_objects&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/deliveries/gateways&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/repositories&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;gopkg.in/square/go-jose.v2&quot;&#10;&#9;&quot;gopkg.in/square/go-jose.v2/jwt&quot;&#10;)&#10;&#10;type AuthUseCase struct {&#10;&#9;AccountRepository *repositories.AccountRepository&#10;&#9;AuthGateway       *gateways.AuthGateway&#10;}&#10;&#10;func NewAuthUseCase(&#10;&#9;accountRepository *repositories.AccountRepository,&#10;&#9;authGateway *gateways.AuthGateway,&#10;) *AuthUseCase {&#10;&#9;return &amp;AuthUseCase{&#10;&#9;&#9;AccountRepository: accountRepository,&#10;&#9;&#9;AuthGateway:       authGateway,&#10;&#9;}&#10;}&#10;&#10;func (uc *AuthUseCase) Register(ctx context.Context, account *entities.Account) (*entities.Account, error) {&#10;&#9;id, err := uuid.NewUUID()&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;account.ID = &amp;id&#10;&#9;account.Scopes = []string{&quot;user&quot;}&#10;&#9;account.TotalPostLike = &amp;[]float64{0}[0]&#10;&#9;account.TotalChatMessage = &amp;[]float64{0}[0]&#10;&#10;&#9;createdAccount, err := uc.AccountRepository.CreateAccount(ctx, account)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return createdAccount, nil&#10;}&#10;&#10;func (uc *AuthUseCase) createToken(ctx context.Context, claims *value_objects.Claims) (string, error) {&#10;&#9;privateKey, err := uc.AuthGateway.GetJwksPrivateKey(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#10;&#9;block, _ := pem.Decode([]byte(privateKey))&#10;&#9;parseResult, _ := x509.ParsePKCS8PrivateKey(block.Bytes)&#10;&#9;key := parseResult.(*rsa.PrivateKey)&#10;&#9;opts := &amp;jose.SignerOptions{}&#10;&#9;signer, err := jose.NewSigner(&#10;&#9;&#9;jose.SigningKey{Algorithm: jose.RS256, Key: key},&#10;&#9;&#9;opts.WithType(&quot;JWT&quot;).WithHeader(&quot;kid&quot;, &quot;social-media-backend-key&quot;),&#10;&#9;)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#10;&#9;}&#10;&#10;&#9;token, err := jwt.Signed(signer).Claims(claims).CompactSerialize()&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#10;&#9;return token, nil&#10;}&#10;&#10;func (uc *AuthUseCase) Login(ctx context.Context, email string, password string) (*value_objects.Session, error) {&#10;&#9;foundAccount, err := uc.AccountRepository.GetAccountByEmailAndPassword(ctx, email, password)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;timeNow := time.Now()&#10;&#10;&#9;accessTokenClaims := &amp;value_objects.Claims{&#10;&#9;&#9;Subject:  foundAccount.ID.String(),&#10;&#9;&#9;IssuedAt: jwt.NewNumericDate(timeNow),&#10;&#9;&#9;Expiry:   jwt.NewNumericDate(timeNow.Add(15 * time.Minute)),&#10;&#9;&#9;Issuer:   &quot;social-media-backend-1&quot;,&#10;&#9;&#9;Scope:    strings.Join(foundAccount.Scopes, &quot; &quot;),&#10;&#9;&#9;Audience: &amp;jwt.Audience{&quot;social-media-backend&quot;},&#10;&#9;}&#10;&#9;accessToken, err := uc.createToken(ctx, accessTokenClaims)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;refreshTokenClaims := &amp;value_objects.Claims{&#10;&#9;&#9;Subject:  foundAccount.ID.String(),&#10;&#9;&#9;IssuedAt: jwt.NewNumericDate(timeNow),&#10;&#9;&#9;Expiry:   jwt.NewNumericDate(timeNow.Add(24 * time.Hour)),&#10;&#9;&#9;Issuer:   &quot;social-media-backend-1&quot;,&#10;&#9;&#9;Scope:    strings.Join(foundAccount.Scopes, &quot; &quot;),&#10;&#9;&#9;Audience: &amp;jwt.Audience{&quot;social-media-backend&quot;},&#10;&#9;}&#10;&#9;refreshToken, err := uc.createToken(ctx, refreshTokenClaims)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;session := &amp;value_objects.Session{&#10;&#9;&#9;Account:      foundAccount,&#10;&#9;&#9;AccessToken:  accessToken,&#10;&#9;&#9;RefreshToken: refreshToken,&#10;&#9;}&#10;&#10;&#9;return session, nil&#10;}&#10;" />
              <option name="updatedContent" value="package use_cases&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;crypto/rsa&quot;&#10;&#9;&quot;crypto/x509&quot;&#10;&#9;&quot;encoding/pem&quot;&#10;&#9;&quot;social-media-backend-1/internal/inners/models/entities&quot;&#10;&#9;&quot;social-media-backend-1/internal/inners/models/value_objects&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/deliveries/gateways&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/repositories&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;gopkg.in/square/go-jose.v2&quot;&#10;&#9;&quot;gopkg.in/square/go-jose.v2/jwt&quot;&#10;)&#10;&#10;type AuthUseCase struct {&#10;&#9;AccountRepository *repositories.AccountRepository&#10;&#9;AuthGateway       *gateways.AuthGateway&#10;}&#10;&#10;func NewAuthUseCase(&#10;&#9;accountRepository *repositories.AccountRepository,&#10;&#9;authGateway *gateways.AuthGateway,&#10;) *AuthUseCase {&#10;&#9;return &amp;AuthUseCase{&#10;&#9;&#9;AccountRepository: accountRepository,&#10;&#9;&#9;AuthGateway:       authGateway,&#10;&#9;}&#10;}&#10;&#10;func (uc *AuthUseCase) Register(ctx context.Context, account *entities.Account) (*entities.Account, error) {&#10;&#9;id, err := uuid.NewUUID()&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;account.ID = &amp;id&#10;&#9;account.Scopes = []string{&quot;user&quot;}&#10;&#9;account.TotalPostLike = &amp;[]float64{0}[0]&#10;&#9;account.TotalChatMessage = &amp;[]float64{0}[0]&#10;&#10;&#9;createdAccount, err := uc.AccountRepository.CreateAccount(ctx, account)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return createdAccount, nil&#10;}&#10;&#10;func (uc *AuthUseCase) createToken(ctx context.Context, claims *value_objects.Claims) (string, error) {&#10;&#9;privateKey, err := uc.AuthGateway.GetJwksPrivateKey(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#10;&#9;block, _ := pem.Decode([]byte(privateKey))&#10;&#9;parseResult, _ := x509.ParsePKCS8PrivateKey(block.Bytes)&#10;&#9;key := parseResult.(*rsa.PrivateKey)&#10;&#9;opts := &amp;jose.SignerOptions{}&#10;&#9;signer, err := jose.NewSigner(&#10;&#9;&#9;jose.SigningKey{Algorithm: jose.RS256, Key: key},&#10;&#9;&#9;opts.WithType(&quot;JWT&quot;).WithHeader(&quot;kid&quot;, &quot;social-media-backend-key&quot;),&#10;&#9;)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#10;&#9;}&#10;&#10;&#9;token, err := jwt.Signed(signer).Claims(claims).CompactSerialize()&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#10;&#9;return token, nil&#10;}&#10;&#10;func (uc *AuthUseCase) VerifyToken(ctx context.Context, tokenString string) (*value_objects.Claims, error) {&#10;&#9;publicKey, err := uc.AuthGateway.GetJwksPublicKey(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;block, _ := pem.Decode([]byte(publicKey))&#10;&#9;parseResult, _ := x509.ParsePKIXPublicKey(block.Bytes)&#10;&#9;key := parseResult.(*rsa.PublicKey)&#10;&#10;&#9;token, err := jwt.ParseSigned(tokenString)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;claims := &amp;value_objects.Claims{}&#10;&#9;err = token.Claims(key, claims)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return claims, nil&#10;}&#10;&#10;func (uc *AuthUseCase) Login(ctx context.Context, email string, password string) (*value_objects.Session, error) {&#10;&#9;foundAccount, err := uc.AccountRepository.GetAccountByEmailAndPassword(ctx, email, password)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;timeNow := time.Now()&#10;&#10;&#9;accessTokenClaims := &amp;value_objects.Claims{&#10;&#9;&#9;Subject:  foundAccount.ID.String(),&#10;&#9;&#9;IssuedAt: jwt.NewNumericDate(timeNow),&#10;&#9;&#9;Expiry:   jwt.NewNumericDate(timeNow.Add(15 * time.Minute)),&#10;&#9;&#9;Issuer:   &quot;social-media-backend-1&quot;,&#10;&#9;&#9;Scope:    strings.Join(foundAccount.Scopes, &quot; &quot;),&#10;&#9;&#9;Audience: &amp;jwt.Audience{&quot;social-media-backend&quot;},&#10;&#9;}&#10;&#9;accessToken, err := uc.createToken(ctx, accessTokenClaims)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;refreshTokenClaims := &amp;value_objects.Claims{&#10;&#9;&#9;Subject:  foundAccount.ID.String(),&#10;&#9;&#9;IssuedAt: jwt.NewNumericDate(timeNow),&#10;&#9;&#9;Expiry:   jwt.NewNumericDate(timeNow.Add(24 * time.Hour)),&#10;&#9;&#9;Issuer:   &quot;social-media-backend-1&quot;,&#10;&#9;&#9;Scope:    strings.Join(foundAccount.Scopes, &quot; &quot;),&#10;&#9;&#9;Audience: &amp;jwt.Audience{&quot;social-media-backend&quot;},&#10;&#9;}&#10;&#9;refreshToken, err := uc.createToken(ctx, refreshTokenClaims)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;session := &amp;value_objects.Session{&#10;&#9;&#9;Account:      foundAccount,&#10;&#9;&#9;AccessToken:  accessToken,&#10;&#9;&#9;RefreshToken: refreshToken,&#10;&#9;}&#10;&#10;&#9;return session, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;log&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/container&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/deliveries/graphqls&quot;&#10;&#10;&#9;&quot;github.com/99designs/gqlgen/graphql/handler&quot;&#10;&#9;&quot;github.com/99designs/gqlgen/graphql/handler/extension&quot;&#10;&#9;&quot;github.com/99designs/gqlgen/graphql/handler/transport&quot;&#10;&#9;&quot;github.com/99designs/gqlgen/graphql/playground&quot;&#10;)&#10;&#10;func main() {&#10;&#9;port := os.Getenv(&quot;BACKEND_1_PORT&quot;)&#10;&#10;&#9;rootContainer := container.NewRootContainer()&#10;&#10;&#9;resolver := graphqls.NewResolver(rootContainer)&#10;&#9;srv := handler.New(graphqls.NewExecutableSchema(graphqls.Config{Resolvers: resolver}))&#10;&#10;&#9;srv.AddTransport(transport.Options{})&#10;&#9;srv.AddTransport(transport.GET{})&#10;&#9;srv.AddTransport(transport.POST{})&#10;&#9;srv.AddTransport(transport.Websocket{})&#10;&#9;srv.AddTransport(transport.MultipartForm{})&#10;&#10;&#9;srv.Use(extension.Introspection{})&#10;&#10;&#9;mux := http.NewServeMux()&#10;&#9;mux.Handle(&quot;/graphql&quot;, srv)&#10;&#9;mux.Handle(&quot;/graphiql&quot;, playground.Handler(&quot;GraphQL playground&quot;, &quot;/graphql&quot;))&#10;&#10;&#9;addr := &quot;0.0.0.0:&quot; + port&#10;&#9;httpServer := &amp;http.Server{&#10;&#9;&#9;Addr:    addr,&#10;&#9;&#9;Handler: mux,&#10;&#9;}&#10;&#9;log.Fatal(httpServer.ListenAndServe())&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;log&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/container&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/deliveries/graphqls&quot;&#10;&#10;&#9;&quot;github.com/99designs/gqlgen/graphql/handler&quot;&#10;&#9;&quot;github.com/99designs/gqlgen/graphql/handler/extension&quot;&#10;&#9;&quot;github.com/99designs/gqlgen/graphql/handler/transport&quot;&#10;&#9;&quot;github.com/99designs/gqlgen/graphql/playground&quot;&#10;)&#10;&#10;func main() {&#10;&#9;port := os.Getenv(&quot;BACKEND_1_PORT&quot;)&#10;&#10;&#9;rootContainer := container.NewRootContainer()&#10;&#10;&#9;resolver := graphqls.NewResolver(rootContainer)&#10;&#9;srv := handler.New(graphqls.NewExecutableSchema(graphqls.Config{Resolvers: resolver}))&#10;&#10;&#9;srv.AddTransport(transport.Options{})&#10;&#9;srv.AddTransport(transport.GET{})&#10;&#9;srv.AddTransport(transport.POST{})&#10;&#9;srv.AddTransport(transport.Websocket{})&#10;&#9;srv.AddTransport(transport.MultipartForm{})&#10;&#10;&#9;srv.Use(extension.Introspection{})&#10;&#10;&#9;mux := http.NewServeMux()&#10;&#9;mux.Handle(&quot;/graphql&quot;, rootContainer.MiddlewareContainer.AuthMiddleware.GetAuthenticatedAccount(srv))&#10;&#9;mux.Handle(&quot;/graphiql&quot;, playground.Handler(&quot;GraphQL playground&quot;, &quot;/graphql&quot;))&#10;&#10;&#9;addr := &quot;0.0.0.0:&quot; + port&#10;&#9;httpServer := &amp;http.Server{&#10;&#9;&#9;Addr:    addr,&#10;&#9;&#9;Handler: mux,&#10;&#9;}&#10;&#9;log.Fatal(httpServer.ListenAndServe())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/outers/container/middleware_container.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/outers/container/middleware_container.go" />
              <option name="originalContent" value="package container&#10;&#10;import (&#10;&#9;&quot;social-media-backend-1/internal/outers/deliveries/middlewares&quot;&#10;)&#10;&#10;type MiddlewareContainer struct {&#10;&#9;TransactionMiddleware *middlewares.TransactionMiddleware&#10;}&#10;&#10;func NewMiddlewareContainer(repositoryContainer *RepositoryContainer) *MiddlewareContainer {&#10;&#9;return &amp;MiddlewareContainer{&#10;&#9;&#9;TransactionMiddleware: middlewares.NewTransactionMiddleware(repositoryContainer.AccountRepository),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package container&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;social-media-backend-1/internal/outers/deliveries/middlewares&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type MiddlewareContainer struct {&#13;&#10;&#9;AuthMiddleware        *middlewares.AuthMiddleware&#13;&#10;&#9;TransactionMiddleware *middlewares.TransactionMiddleware&#13;&#10;}&#13;&#10;&#13;&#10;func NewMiddlewareContainer(&#13;&#10;&#9;useCaseContainer *UseCaseContainer,&#13;&#10;&#9;repositoryContainer *RepositoryContainer,&#13;&#10;) *MiddlewareContainer {&#13;&#10;&#9;return &amp;MiddlewareContainer{&#13;&#10;&#9;&#9;AuthMiddleware:        middlewares.NewAuthMiddleware(useCaseContainer.AuthUseCase),&#13;&#10;&#9;&#9;TransactionMiddleware: middlewares.NewTransactionMiddleware(repositoryContainer.AccountRepository),&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/outers/container/root_container.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/outers/container/root_container.go" />
              <option name="originalContent" value="package container&#10;&#10;type RootContainer struct {&#10;&#9;ConfigContainer     *ConfigContainer&#10;&#9;RepositoryContainer *RepositoryContainer&#10;&#9;GatewayContainer    *GatewayContainer&#10;&#9;UseCaseContainer    *UseCaseContainer&#10;&#9;MiddlewareContainer *MiddlewareContainer&#10;}&#10;&#10;func NewRootContainer() *RootContainer {&#10;&#9;configContainer := NewConfigContainer()&#10;&#9;repositoryContainer := NewRepositoryContainer(configContainer)&#10;&#9;gatewayContainer := NewGatewayContainer(configContainer)&#10;&#9;useCaseContainer := NewUseCaseContainer(repositoryContainer, gatewayContainer)&#10;&#9;middlewareContainer := NewMiddlewareContainer(repositoryContainer)&#10;&#10;&#9;return &amp;RootContainer{&#10;&#9;&#9;ConfigContainer:     configContainer,&#10;&#9;&#9;RepositoryContainer: repositoryContainer,&#10;&#9;&#9;GatewayContainer:    gatewayContainer,&#10;&#9;&#9;UseCaseContainer:    useCaseContainer,&#10;&#9;&#9;MiddlewareContainer: middlewareContainer,&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package container&#10;&#10;type RootContainer struct {&#10;&#9;ConfigContainer     *ConfigContainer&#10;&#9;RepositoryContainer *RepositoryContainer&#10;&#9;GatewayContainer    *GatewayContainer&#10;&#9;UseCaseContainer    *UseCaseContainer&#10;&#9;MiddlewareContainer *MiddlewareContainer&#10;}&#10;&#10;func NewRootContainer() *RootContainer {&#10;&#9;configContainer := NewConfigContainer()&#10;&#9;repositoryContainer := NewRepositoryContainer(configContainer)&#10;&#9;gatewayContainer := NewGatewayContainer(configContainer)&#10;&#9;useCaseContainer := NewUseCaseContainer(repositoryContainer, gatewayContainer)&#10;&#9;middlewareContainer := NewMiddlewareContainer(useCaseContainer, repositoryContainer)&#10;&#10;&#9;return &amp;RootContainer{&#10;&#9;&#9;ConfigContainer:     configContainer,&#10;&#9;&#9;RepositoryContainer: repositoryContainer,&#10;&#9;&#9;GatewayContainer:    gatewayContainer,&#10;&#9;&#9;UseCaseContainer:    useCaseContainer,&#10;&#9;&#9;MiddlewareContainer: middlewareContainer,&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/outers/deliveries/graphqls/schema.resolvers.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/outers/deliveries/graphqls/schema.resolvers.go" />
              <option name="originalContent" value="package graphqls&#10;&#10;// This file will be automatically regenerated based on the schema, any resolver implementations&#10;// will be copied through when generating and any unknown code will be moved to the end.&#10;// Code generated by github.com/99designs/gqlgen version v0.17.70&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;social-media-backend-1/internal/inners/models/entities&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/deliveries/graphqls/model&quot;&#10;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Account is the resolver for the account field.&#10;func (r *chatMessageResolver) Account(ctx context.Context, obj *model.ChatMessage, federationRequires map[string]any) (*model.Account, error) {&#10;&#9;accountID, ok := federationRequires[&quot;accountId&quot;].(string)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account id is required&quot;)&#10;&#9;}&#10;&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, accountID)&#10;}&#10;&#10;// Account is the resolver for the account field.&#10;func (r *chatRoomMemberResolver) Account(ctx context.Context, obj *model.ChatRoomMember, federationRequires map[string]any) (*model.Account, error) {&#10;&#9;accountID, ok := federationRequires[&quot;accountId&quot;].(string)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account id is required&quot;)&#10;&#9;}&#10;&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, accountID)&#10;}&#10;&#10;// Login is the resolver for the login field.&#10;func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.Session, error) {&#10;&#9;session, err := r.RootContainer.UseCaseContainer.AuthUseCase.Login(ctx, input.Email, input.Password)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;account := &amp;model.Account{&#10;&#9;&#9;ID:               session.Account.ID.String(),&#10;&#9;&#9;ImageURL:         session.Account.ImageURL,&#10;&#9;&#9;Name:             *session.Account.Name,&#10;&#9;&#9;Email:            *session.Account.Email,&#10;&#9;&#9;Password:         *session.Account.Password,&#10;&#9;&#9;Scopes:           session.Account.Scopes,&#10;&#9;&#9;TotalPostLike:    *session.Account.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *session.Account.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Session{&#10;&#9;&#9;Account:      account,&#10;&#9;&#9;AccessToken:  session.AccessToken,&#10;&#9;&#9;RefreshToken: session.RefreshToken,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// Register is the resolver for the register field.&#10;func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.Account, error) {&#10;&#9;account := &amp;entities.Account{&#10;&#9;&#9;Name:     &amp;input.Name,&#10;&#9;&#9;Email:    &amp;input.Email,&#10;&#9;&#9;Password: &amp;input.Password,&#10;&#9;}&#10;&#9;registeredAccount, err := r.RootContainer.UseCaseContainer.AuthUseCase.Register(ctx, account)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Account{&#10;&#9;&#9;ID:               registeredAccount.ID.String(),&#10;&#9;&#9;ImageURL:         registeredAccount.ImageURL,&#10;&#9;&#9;Name:             *registeredAccount.Name,&#10;&#9;&#9;Email:            *registeredAccount.Email,&#10;&#9;&#9;Password:         *registeredAccount.Password,&#10;&#9;&#9;Scopes:           registeredAccount.Scopes,&#10;&#9;&#9;TotalPostLike:    *registeredAccount.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *registeredAccount.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// CreateAccount is the resolver for the createAccount field.&#10;func (r *mutationResolver) CreateAccount(ctx context.Context, input model.AccountInput) (*model.Account, error) {&#10;&#9;id, err := uuid.NewUUID()&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;account := &amp;entities.Account{&#10;&#9;&#9;ID:               &amp;id,&#10;&#9;&#9;Image:            input.Image,&#10;&#9;&#9;Name:             &amp;input.Name,&#10;&#9;&#9;Email:            &amp;input.Email,&#10;&#9;&#9;Password:         &amp;input.Password,&#10;&#9;&#9;Scopes:           input.Scopes,&#10;&#9;&#9;TotalPostLike:    &amp;[]float64{0}[0],&#10;&#9;&#9;TotalChatMessage: &amp;[]float64{0}[0],&#10;&#9;}&#10;&#10;&#9;createdAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.CreateAccount(ctx, account)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Account{&#10;&#9;&#9;ID:               createdAccount.ID.String(),&#10;&#9;&#9;ImageURL:         createdAccount.ImageURL,&#10;&#9;&#9;Name:             *createdAccount.Name,&#10;&#9;&#9;Email:            *createdAccount.Email,&#10;&#9;&#9;Password:         *createdAccount.Password,&#10;&#9;&#9;Scopes:           createdAccount.Scopes,&#10;&#9;&#9;TotalPostLike:    *createdAccount.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *createdAccount.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// UpdateAccount is the resolver for the updateAccount field.&#10;func (r *mutationResolver) UpdateAccount(ctx context.Context, id string, input model.AccountInput) (*model.Account, error) {&#10;&#9;convertedID, err := uuid.Parse(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountByID(ctx, convertedID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if foundAccount == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account not found&quot;)&#10;&#9;}&#10;&#10;&#9;foundAccount.Image = input.Image&#10;&#9;foundAccount.Name = &amp;input.Name&#10;&#9;foundAccount.Email = &amp;input.Email&#10;&#9;foundAccount.Password = &amp;input.Password&#10;&#9;foundAccount.Scopes = input.Scopes&#10;&#9;updatedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.UpdateAccountByID(ctx, convertedID, foundAccount)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Account{&#10;&#9;&#9;ID:               updatedAccount.ID.String(),&#10;&#9;&#9;ImageURL:         updatedAccount.ImageURL,&#10;&#9;&#9;Name:             *updatedAccount.Name,&#10;&#9;&#9;Email:            *updatedAccount.Email,&#10;&#9;&#9;Password:         *updatedAccount.Password,&#10;&#9;&#9;Scopes:           updatedAccount.Scopes,&#10;&#9;&#9;TotalPostLike:    *updatedAccount.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *updatedAccount.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// UpdateMyAccount is the resolver for the updateMyAccount field.&#10;func (r *mutationResolver) UpdateMyAccount(ctx context.Context, input model.AccountInput) (*model.Account, error) {&#10;&#9;panic(fmt.Errorf(&quot;not implemented: UpdateMyAccount - updateMyAccount&quot;))&#10;}&#10;&#10;// DeleteAccount is the resolver for the deleteAccount field.&#10;func (r *mutationResolver) DeleteAccount(ctx context.Context, id string) (*model.Account, error) {&#10;&#9;convertedID, err := uuid.Parse(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountByID(ctx, convertedID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if foundAccount == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account not found&quot;)&#10;&#9;}&#10;&#10;&#9;deletedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.DeleteAccountByID(ctx, convertedID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Account{&#10;&#9;&#9;ID:               deletedAccount.ID.String(),&#10;&#9;&#9;ImageURL:         deletedAccount.ImageURL,&#10;&#9;&#9;Name:             *deletedAccount.Name,&#10;&#9;&#9;Email:            *deletedAccount.Email,&#10;&#9;&#9;Password:         *deletedAccount.Password,&#10;&#9;&#9;Scopes:           deletedAccount.Scopes,&#10;&#9;&#9;TotalPostLike:    *deletedAccount.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *deletedAccount.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// Account is the resolver for the account field.&#10;func (r *postResolver) Account(ctx context.Context, obj *model.Post, federationRequires map[string]any) (*model.Account, error) {&#10;&#9;accountID, ok := federationRequires[&quot;accountId&quot;].(string)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account id is required&quot;)&#10;&#9;}&#10;&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, accountID)&#10;}&#10;&#10;// Account is the resolver for the account field.&#10;func (r *postLikeResolver) Account(ctx context.Context, obj *model.PostLike, federationRequires map[string]any) (*model.Account, error) {&#10;&#9;accountID, ok := federationRequires[&quot;accountId&quot;].(string)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account id is required&quot;)&#10;&#9;}&#10;&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, accountID)&#10;}&#10;&#10;// Accounts is the resolver for the accounts field.&#10;func (r *queryResolver) Accounts(ctx context.Context) ([]*model.Account, error) {&#10;&#9;foundAccounts, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAllAccounts(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;var result []*model.Account&#10;&#9;for _, foundAccount := range foundAccounts {&#10;&#9;&#9;result = append(result, &amp;model.Account{&#10;&#9;&#9;&#9;ID:               foundAccount.ID.String(),&#10;&#9;&#9;&#9;ImageURL:         foundAccount.ImageURL,&#10;&#9;&#9;&#9;Name:             *foundAccount.Name,&#10;&#9;&#9;&#9;Email:            *foundAccount.Email,&#10;&#9;&#9;&#9;Password:         *foundAccount.Password,&#10;&#9;&#9;&#9;Scopes:           foundAccount.Scopes,&#10;&#9;&#9;&#9;TotalPostLike:    *foundAccount.TotalPostLike,&#10;&#9;&#9;&#9;TotalChatMessage: *foundAccount.TotalChatMessage,&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// Account is the resolver for the account field.&#10;func (r *queryResolver) Account(ctx context.Context, id string) (*model.Account, error) {&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, id)&#10;}&#10;&#10;// ChatMessage returns ChatMessageResolver implementation.&#10;func (r *Resolver) ChatMessage() ChatMessageResolver { return &amp;chatMessageResolver{r} }&#10;&#10;// ChatRoomMember returns ChatRoomMemberResolver implementation.&#10;func (r *Resolver) ChatRoomMember() ChatRoomMemberResolver { return &amp;chatRoomMemberResolver{r} }&#10;&#10;// Mutation returns MutationResolver implementation.&#10;func (r *Resolver) Mutation() MutationResolver { return &amp;mutationResolver{r} }&#10;&#10;// Post returns PostResolver implementation.&#10;func (r *Resolver) Post() PostResolver { return &amp;postResolver{r} }&#10;&#10;// PostLike returns PostLikeResolver implementation.&#10;func (r *Resolver) PostLike() PostLikeResolver { return &amp;postLikeResolver{r} }&#10;&#10;// Query returns QueryResolver implementation.&#10;func (r *Resolver) Query() QueryResolver { return &amp;queryResolver{r} }&#10;&#10;type chatMessageResolver struct{ *Resolver }&#10;type chatRoomMemberResolver struct{ *Resolver }&#10;type mutationResolver struct{ *Resolver }&#10;type postResolver struct{ *Resolver }&#10;type postLikeResolver struct{ *Resolver }&#10;type queryResolver struct{ *Resolver }&#10;" />
              <option name="updatedContent" value="package graphqls&#10;&#10;// This file will be automatically regenerated based on the schema, any resolver implementations&#10;// will be copied through when generating and any unknown code will be moved to the end.&#10;// Code generated by github.com/99designs/gqlgen version v0.17.70&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;social-media-backend-1/internal/inners/models/entities&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/deliveries/graphqls/model&quot;&#10;&#9;&quot;social-media-backend-1/internal/outers/deliveries/middlewares&quot;&#10;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Account is the resolver for the account field.&#10;func (r *chatMessageResolver) Account(ctx context.Context, obj *model.ChatMessage, federationRequires map[string]any) (*model.Account, error) {&#10;&#9;accountID, ok := federationRequires[&quot;accountId&quot;].(string)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account id is required&quot;)&#10;&#9;}&#10;&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, accountID)&#10;}&#10;&#10;// Account is the resolver for the account field.&#10;func (r *chatRoomMemberResolver) Account(ctx context.Context, obj *model.ChatRoomMember, federationRequires map[string]any) (*model.Account, error) {&#10;&#9;accountID, ok := federationRequires[&quot;accountId&quot;].(string)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account id is required&quot;)&#10;&#9;}&#10;&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, accountID)&#10;}&#10;&#10;// Login is the resolver for the login field.&#10;func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.Session, error) {&#10;&#9;session, err := r.RootContainer.UseCaseContainer.AuthUseCase.Login(ctx, input.Email, input.Password)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;account := &amp;model.Account{&#10;&#9;&#9;ID:               session.Account.ID.String(),&#10;&#9;&#9;ImageURL:         session.Account.ImageURL,&#10;&#9;&#9;Name:             *session.Account.Name,&#10;&#9;&#9;Email:            *session.Account.Email,&#10;&#9;&#9;Password:         *session.Account.Password,&#10;&#9;&#9;Scopes:           session.Account.Scopes,&#10;&#9;&#9;TotalPostLike:    *session.Account.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *session.Account.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Session{&#10;&#9;&#9;Account:      account,&#10;&#9;&#9;AccessToken:  session.AccessToken,&#10;&#9;&#9;RefreshToken: session.RefreshToken,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// Register is the resolver for the register field.&#10;func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.Account, error) {&#10;&#9;account := &amp;entities.Account{&#10;&#9;&#9;Name:     &amp;input.Name,&#10;&#9;&#9;Email:    &amp;input.Email,&#10;&#9;&#9;Password: &amp;input.Password,&#10;&#9;}&#10;&#9;registeredAccount, err := r.RootContainer.UseCaseContainer.AuthUseCase.Register(ctx, account)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Account{&#10;&#9;&#9;ID:               registeredAccount.ID.String(),&#10;&#9;&#9;ImageURL:         registeredAccount.ImageURL,&#10;&#9;&#9;Name:             *registeredAccount.Name,&#10;&#9;&#9;Email:            *registeredAccount.Email,&#10;&#9;&#9;Password:         *registeredAccount.Password,&#10;&#9;&#9;Scopes:           registeredAccount.Scopes,&#10;&#9;&#9;TotalPostLike:    *registeredAccount.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *registeredAccount.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// CreateAccount is the resolver for the createAccount field.&#10;func (r *mutationResolver) CreateAccount(ctx context.Context, input model.AccountInput) (*model.Account, error) {&#10;&#9;id, err := uuid.NewUUID()&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;account := &amp;entities.Account{&#10;&#9;&#9;ID:               &amp;id,&#10;&#9;&#9;Image:            input.Image,&#10;&#9;&#9;Name:             &amp;input.Name,&#10;&#9;&#9;Email:            &amp;input.Email,&#10;&#9;&#9;Password:         &amp;input.Password,&#10;&#9;&#9;Scopes:           input.Scopes,&#10;&#9;&#9;TotalPostLike:    &amp;[]float64{0}[0],&#10;&#9;&#9;TotalChatMessage: &amp;[]float64{0}[0],&#10;&#9;}&#10;&#10;&#9;createdAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.CreateAccount(ctx, account)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Account{&#10;&#9;&#9;ID:               createdAccount.ID.String(),&#10;&#9;&#9;ImageURL:         createdAccount.ImageURL,&#10;&#9;&#9;Name:             *createdAccount.Name,&#10;&#9;&#9;Email:            *createdAccount.Email,&#10;&#9;&#9;Password:         *createdAccount.Password,&#10;&#9;&#9;Scopes:           createdAccount.Scopes,&#10;&#9;&#9;TotalPostLike:    *createdAccount.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *createdAccount.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// UpdateAccount is the resolver for the updateAccount field.&#10;func (r *mutationResolver) UpdateAccount(ctx context.Context, id string, input model.AccountInput) (*model.Account, error) {&#10;&#9;convertedID, err := uuid.Parse(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountByID(ctx, convertedID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if foundAccount == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account not found&quot;)&#10;&#9;}&#10;&#10;&#9;foundAccount.Image = input.Image&#10;&#9;foundAccount.Name = &amp;input.Name&#10;&#9;foundAccount.Email = &amp;input.Email&#10;&#9;foundAccount.Password = &amp;input.Password&#10;&#9;foundAccount.Scopes = input.Scopes&#10;&#9;updatedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.UpdateAccountByID(ctx, convertedID, foundAccount)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Account{&#10;&#9;&#9;ID:               updatedAccount.ID.String(),&#10;&#9;&#9;ImageURL:         updatedAccount.ImageURL,&#10;&#9;&#9;Name:             *updatedAccount.Name,&#10;&#9;&#9;Email:            *updatedAccount.Email,&#10;&#9;&#9;Password:         *updatedAccount.Password,&#10;&#9;&#9;Scopes:           updatedAccount.Scopes,&#10;&#9;&#9;TotalPostLike:    *updatedAccount.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *updatedAccount.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// UpdateMyAccount is the resolver for the updateMyAccount field.&#10;func (r *mutationResolver) UpdateMyAccount(ctx context.Context, input model.AccountInput) (*model.Account, error) {&#10;&#9;claims := middlewares.ForContext(ctx)&#10;&#9;if claims == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;unauthorized&quot;)&#10;&#9;}&#10;&#10;&#9;convertedID, err := uuid.Parse(claims.Subject)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountByID(ctx, convertedID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if foundAccount == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account not found&quot;)&#10;&#9;}&#10;&#10;&#9;foundAccount.Image = input.Image&#10;&#9;foundAccount.Name = &amp;input.Name&#10;&#9;foundAccount.Email = &amp;input.Email&#10;&#9;foundAccount.Password = &amp;input.Password&#10;&#9;foundAccount.Scopes = input.Scopes&#10;&#9;updatedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.UpdateAccountByID(ctx, convertedID, foundAccount)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Account{&#10;&#9;&#9;ID:               updatedAccount.ID.String(),&#10;&#9;&#9;ImageURL:         updatedAccount.ImageURL,&#10;&#9;&#9;Name:             *updatedAccount.Name,&#10;&#9;&#9;Email:            *updatedAccount.Email,&#10;&#9;&#9;Password:         *updatedAccount.Password,&#10;&#9;&#9;Scopes:           updatedAccount.Scopes,&#10;&#9;&#9;TotalPostLike:    *updatedAccount.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *updatedAccount.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// DeleteAccount is the resolver for the deleteAccount field.&#10;func (r *mutationResolver) DeleteAccount(ctx context.Context, id string) (*model.Account, error) {&#10;&#9;convertedID, err := uuid.Parse(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountByID(ctx, convertedID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if foundAccount == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account not found&quot;)&#10;&#9;}&#10;&#10;&#9;deletedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.DeleteAccountByID(ctx, convertedID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;result := &amp;model.Account{&#10;&#9;&#9;ID:               deletedAccount.ID.String(),&#10;&#9;&#9;ImageURL:         deletedAccount.ImageURL,&#10;&#9;&#9;Name:             *deletedAccount.Name,&#10;&#9;&#9;Email:            *deletedAccount.Email,&#10;&#9;&#9;Password:         *deletedAccount.Password,&#10;&#9;&#9;Scopes:           deletedAccount.Scopes,&#10;&#9;&#9;TotalPostLike:    *deletedAccount.TotalPostLike,&#10;&#9;&#9;TotalChatMessage: *deletedAccount.TotalChatMessage,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// Account is the resolver for the account field.&#10;func (r *postResolver) Account(ctx context.Context, obj *model.Post, federationRequires map[string]any) (*model.Account, error) {&#10;&#9;accountID, ok := federationRequires[&quot;accountId&quot;].(string)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account id is required&quot;)&#10;&#9;}&#10;&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, accountID)&#10;}&#10;&#10;// Account is the resolver for the account field.&#10;func (r *postLikeResolver) Account(ctx context.Context, obj *model.PostLike, federationRequires map[string]any) (*model.Account, error) {&#10;&#9;accountID, ok := federationRequires[&quot;accountId&quot;].(string)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;account id is required&quot;)&#10;&#9;}&#10;&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, accountID)&#10;}&#10;&#10;// Accounts is the resolver for the accounts field.&#10;func (r *queryResolver) Accounts(ctx context.Context) ([]*model.Account, error) {&#10;&#9;foundAccounts, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAllAccounts(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;var result []*model.Account&#10;&#9;for _, foundAccount := range foundAccounts {&#10;&#9;&#9;result = append(result, &amp;model.Account{&#10;&#9;&#9;&#9;ID:               foundAccount.ID.String(),&#10;&#9;&#9;&#9;ImageURL:         foundAccount.ImageURL,&#10;&#9;&#9;&#9;Name:             *foundAccount.Name,&#10;&#9;&#9;&#9;Email:            *foundAccount.Email,&#10;&#9;&#9;&#9;Password:         *foundAccount.Password,&#10;&#9;&#9;&#9;Scopes:           foundAccount.Scopes,&#10;&#9;&#9;&#9;TotalPostLike:    *foundAccount.TotalPostLike,&#10;&#9;&#9;&#9;TotalChatMessage: *foundAccount.TotalChatMessage,&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;// Account is the resolver for the account field.&#10;func (r *queryResolver) Account(ctx context.Context, id string) (*model.Account, error) {&#10;&#9;return r.Dataloader.AccountDataloader.Load(ctx, id)&#10;}&#10;&#10;// ChatMessage returns ChatMessageResolver implementation.&#10;func (r *Resolver) ChatMessage() ChatMessageResolver { return &amp;chatMessageResolver{r} }&#10;&#10;// ChatRoomMember returns ChatRoomMemberResolver implementation.&#10;func (r *Resolver) ChatRoomMember() ChatRoomMemberResolver { return &amp;chatRoomMemberResolver{r} }&#10;&#10;// Mutation returns MutationResolver implementation.&#10;func (r *Resolver) Mutation() MutationResolver { return &amp;mutationResolver{r} }&#10;&#10;// Post returns PostResolver implementation.&#10;func (r *Resolver) Post() PostResolver { return &amp;postResolver{r} }&#10;&#10;// PostLike returns PostLikeResolver implementation.&#10;func (r *Resolver) PostLike() PostLikeResolver { return &amp;postLikeResolver{r} }&#10;&#10;// Query returns QueryResolver implementation.&#10;func (r *Resolver) Query() QueryResolver { return &amp;queryResolver{r} }&#10;&#10;type chatMessageResolver struct{ *Resolver }&#10;type chatRoomMemberResolver struct{ *Resolver }&#10;type mutationResolver struct{ *Resolver }&#10;type postResolver struct{ *Resolver }&#10;type postLikeResolver struct{ *Resolver }&#10;type queryResolver struct{ *Resolver }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/outers/deliveries/middlewares/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/outers/deliveries/middlewares/auth_middleware.go" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package middlewares&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;social-media-backend-1/internal/inners/models/value_objects&quot;&#10;&#9;&quot;social-media-backend-1/internal/inners/use_cases&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;var AccountCtxKey = &amp;contextKey{&quot;account&quot;}&#10;&#10;type contextKey struct {&#10;&#9;name string&#10;}&#10;&#10;type AuthMiddleware struct {&#10;&#9;AuthUseCase *use_cases.AuthUseCase&#10;}&#10;&#10;func NewAuthMiddleware(&#10;&#9;authUseCase *use_cases.AuthUseCase,&#10;) *AuthMiddleware {&#10;&#9;return &amp;AuthMiddleware{&#10;&#9;&#9;AuthUseCase: authUseCase,&#10;&#9;}&#10;}&#10;&#10;func (m *AuthMiddleware) GetAuthenticatedAccount(next http.Handler) http.Handler {&#10;&#9;return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {&#10;&#9;&#9;authHeader := r.Header.Get(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;next.ServeHTTP(w, r)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.Replace(authHeader, &quot;Bearer &quot;, &quot;&quot;, 1)&#10;&#9;&#9;claims, err := m.AuthUseCase.VerifyToken(r.Context(), tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;next.ServeHTTP(w, r)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx := context.WithValue(r.Context(), AccountCtxKey, claims)&#10;&#9;&#9;next.ServeHTTP(w, r.WithContext(ctx))&#10;&#9;})&#10;}&#10;&#10;func ForContext(ctx context.Context) *value_objects.Claims {&#10;&#9;raw, _ := ctx.Value(AccountCtxKey).(*value_objects.Claims)&#10;&#9;return raw&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>