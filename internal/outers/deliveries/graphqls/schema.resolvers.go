package graphqls

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"slices"
	"social-media-backend-1/internal/inners/models/entities"
	"social-media-backend-1/internal/outers/deliveries/graphqls/model"
	"social-media-backend-1/internal/outers/deliveries/middlewares"
	"strings"

	"github.com/google/uuid"
)

// Account is the resolver for the account field.
func (r *chatMessageResolver) Account(ctx context.Context, obj *model.ChatMessage, federationRequires map[string]any) (*model.Account, error) {
	accountID, ok := federationRequires["accountId"].(string)
	if !ok {
		return nil, fmt.Errorf("account id is required")
	}

	return r.Dataloader.AccountDataloader.Load(ctx, accountID)
}

// Account is the resolver for the account field.
func (r *chatRoomMemberResolver) Account(ctx context.Context, obj *model.ChatRoomMember, federationRequires map[string]any) (*model.Account, error) {
	accountID, ok := federationRequires["accountId"].(string)
	if !ok {
		return nil, fmt.Errorf("account id is required")
	}

	return r.Dataloader.AccountDataloader.Load(ctx, accountID)
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.Session, error) {
	session, err := r.RootContainer.UseCaseContainer.AuthUseCase.Login(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	account := &model.Account{
		ID:               session.Account.ID.String(),
		ImageURL:         session.Account.ImageURL,
		Name:             *session.Account.Name,
		Email:            *session.Account.Email,
		Password:         *session.Account.Password,
		Scopes:           session.Account.Scopes,
		TotalPostLike:    *session.Account.TotalPostLike,
		TotalChatMessage: *session.Account.TotalChatMessage,
	}

	result := &model.Session{
		Account:      account,
		AccessToken:  session.AccessToken,
		RefreshToken: session.RefreshToken,
	}

	return result, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.Account, error) {
	account := &entities.Account{
		Name:     &input.Name,
		Email:    &input.Email,
		Password: &input.Password,
	}
	registeredAccount, err := r.RootContainer.UseCaseContainer.AuthUseCase.Register(ctx, account)
	if err != nil {
		return nil, err
	}

	result := &model.Account{
		ID:               registeredAccount.ID.String(),
		ImageURL:         registeredAccount.ImageURL,
		Name:             *registeredAccount.Name,
		Email:            *registeredAccount.Email,
		Password:         *registeredAccount.Password,
		Scopes:           registeredAccount.Scopes,
		TotalPostLike:    *registeredAccount.TotalPostLike,
		TotalChatMessage: *registeredAccount.TotalChatMessage,
	}

	return result, nil
}

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, input model.AccountInput) (*model.Account, error) {
	claims := middlewares.GetClaimContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	scopes := strings.Split(claims.Scope, " ")
	if !slices.Contains(scopes, "admin") {
		return nil, fmt.Errorf("unauthorized: admin scope required")
	}

	id, err := uuid.NewUUID()
	if err != nil {
		return nil, err
	}

	account := &entities.Account{
		ID:               &id,
		Image:            input.Image,
		Name:             &input.Name,
		Email:            &input.Email,
		Password:         &input.Password,
		Scopes:           input.Scopes,
		TotalPostLike:    &[]float64{0}[0],
		TotalChatMessage: &[]float64{0}[0],
	}

	createdAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.CreateAccount(ctx, account)
	if err != nil {
		return nil, err
	}

	result := &model.Account{
		ID:               createdAccount.ID.String(),
		ImageURL:         createdAccount.ImageURL,
		Name:             *createdAccount.Name,
		Email:            *createdAccount.Email,
		Password:         *createdAccount.Password,
		Scopes:           createdAccount.Scopes,
		TotalPostLike:    *createdAccount.TotalPostLike,
		TotalChatMessage: *createdAccount.TotalChatMessage,
	}

	return result, nil
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, id string, input model.AccountInput) (*model.Account, error) {
	claims := middlewares.GetClaimContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	scopes := strings.Split(claims.Scope, " ")
	if !slices.Contains(scopes, "admin") {
		return nil, fmt.Errorf("unauthorized: admin scope required")
	}

	convertedID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountByID(ctx, &convertedID)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	foundAccount.Image = input.Image
	foundAccount.Name = &input.Name
	foundAccount.Email = &input.Email
	foundAccount.Password = &input.Password
	foundAccount.Scopes = input.Scopes
	updatedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.UpdateAccountByID(ctx, &convertedID, foundAccount)
	if err != nil {
		return nil, err
	}

	result := &model.Account{
		ID:               updatedAccount.ID.String(),
		ImageURL:         updatedAccount.ImageURL,
		Name:             *updatedAccount.Name,
		Email:            *updatedAccount.Email,
		Password:         *updatedAccount.Password,
		Scopes:           updatedAccount.Scopes,
		TotalPostLike:    *updatedAccount.TotalPostLike,
		TotalChatMessage: *updatedAccount.TotalChatMessage,
	}

	return result, nil
}

// UpdateMyAccount is the resolver for the updateMyAccount field.
func (r *mutationResolver) UpdateMyAccount(ctx context.Context, input model.AccountInput) (*model.Account, error) {
	claims := middlewares.GetClaimContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	convertedID, err := uuid.Parse(claims.Subject)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountByID(ctx, &convertedID)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	foundAccount.Image = input.Image
	foundAccount.Name = &input.Name
	foundAccount.Email = &input.Email
	foundAccount.Password = &input.Password
	foundAccount.Scopes = input.Scopes
	updatedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.UpdateAccountByID(ctx, &convertedID, foundAccount)
	if err != nil {
		return nil, err
	}

	result := &model.Account{
		ID:               updatedAccount.ID.String(),
		ImageURL:         updatedAccount.ImageURL,
		Name:             *updatedAccount.Name,
		Email:            *updatedAccount.Email,
		Password:         *updatedAccount.Password,
		Scopes:           updatedAccount.Scopes,
		TotalPostLike:    *updatedAccount.TotalPostLike,
		TotalChatMessage: *updatedAccount.TotalChatMessage,
	}

	return result, nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, id string) (*model.Account, error) {
	claims := middlewares.GetClaimContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	scopes := strings.Split(claims.Scope, " ")
	if !slices.Contains(scopes, "admin") {
		return nil, fmt.Errorf("unauthorized: admin scope required")
	}

	convertedID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountByID(ctx, &convertedID)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	deletedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.DeleteAccountByID(ctx, &convertedID)
	if err != nil {
		return nil, err
	}

	result := &model.Account{
		ID:               deletedAccount.ID.String(),
		ImageURL:         deletedAccount.ImageURL,
		Name:             *deletedAccount.Name,
		Email:            *deletedAccount.Email,
		Password:         *deletedAccount.Password,
		Scopes:           deletedAccount.Scopes,
		TotalPostLike:    *deletedAccount.TotalPostLike,
		TotalChatMessage: *deletedAccount.TotalChatMessage,
	}

	return result, nil
}

// Account is the resolver for the account field.
func (r *postResolver) Account(ctx context.Context, obj *model.Post, federationRequires map[string]any) (*model.Account, error) {
	accountID, ok := federationRequires["accountId"].(string)
	if !ok {
		return nil, fmt.Errorf("account id is required")
	}

	return r.Dataloader.AccountDataloader.Load(ctx, accountID)
}

// Account is the resolver for the account field.
func (r *postLikeResolver) Account(ctx context.Context, obj *model.PostLike, federationRequires map[string]any) (*model.Account, error) {
	accountID, ok := federationRequires["accountId"].(string)
	if !ok {
		return nil, fmt.Errorf("account id is required")
	}

	return r.Dataloader.AccountDataloader.Load(ctx, accountID)
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context) ([]*model.Account, error) {
	foundAccounts, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAllAccounts(ctx)
	if err != nil {
		return nil, err
	}

	var result []*model.Account
	for _, foundAccount := range foundAccounts {
		result = append(result, &model.Account{
			ID:               foundAccount.ID.String(),
			ImageURL:         foundAccount.ImageURL,
			Name:             *foundAccount.Name,
			Email:            *foundAccount.Email,
			Password:         *foundAccount.Password,
			Scopes:           foundAccount.Scopes,
			TotalPostLike:    *foundAccount.TotalPostLike,
			TotalChatMessage: *foundAccount.TotalChatMessage,
		})
	}

	return result, nil
}

// Account is the resolver for the account field.
func (r *queryResolver) Account(ctx context.Context, id string) (*model.Account, error) {
	return r.Dataloader.AccountDataloader.Load(ctx, id)
}

// ChatMessage returns ChatMessageResolver implementation.
func (r *Resolver) ChatMessage() ChatMessageResolver { return &chatMessageResolver{r} }

// ChatRoomMember returns ChatRoomMemberResolver implementation.
func (r *Resolver) ChatRoomMember() ChatRoomMemberResolver { return &chatRoomMemberResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// PostLike returns PostLikeResolver implementation.
func (r *Resolver) PostLike() PostLikeResolver { return &postLikeResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type chatMessageResolver struct{ *Resolver }
type chatRoomMemberResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type postLikeResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
