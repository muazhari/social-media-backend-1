package graphqls

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"social-media-backend-1/internal/inners/models/entities"
	"social-media-backend-1/internal/outers/deliveries/graphqls/model"

	"github.com/google/uuid"
)

// Account is the resolver for the account field.
func (r *chatMessageResolver) Account(ctx context.Context, obj *model.ChatMessage, federationRequires map[string]any) (*model.Account, error) {
	accountId, ok := federationRequires["accountId"].(string)
	if !ok {
		return nil, fmt.Errorf("account id is required")
	}

	convertedId, err := uuid.Parse(accountId)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountById(convertedId)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	result := &model.Account{
		ID:               foundAccount.ID.String(),
		Name:             foundAccount.Name,
		Email:            foundAccount.Email,
		Password:         foundAccount.Password,
		TotalPostLike:    foundAccount.TotalPostLike,
		TotalChatMessage: foundAccount.TotalChatMessage,
	}

	return result, nil
}

// Account is the resolver for the account field.
func (r *chatRoomMemberResolver) Account(ctx context.Context, obj *model.ChatRoomMember, federationRequires map[string]any) (*model.Account, error) {
	accountId, ok := federationRequires["accountId"].(string)
	if !ok {
		return nil, fmt.Errorf("account id is required")
	}

	convertedId, err := uuid.Parse(accountId)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountById(convertedId)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	result := &model.Account{
		ID:               foundAccount.ID.String(),
		Name:             foundAccount.Name,
		Email:            foundAccount.Email,
		Password:         foundAccount.Password,
		TotalPostLike:    foundAccount.TotalPostLike,
		TotalChatMessage: foundAccount.TotalChatMessage,
	}

	return result, nil
}

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, input model.AccountInput) (*model.Account, error) {
	id, err := uuid.NewUUID()
	if err != nil {
		return nil, err
	}

	account := &entities.Account{
		ID:               &id,
		Name:             input.Name,
		Email:            input.Email,
		Password:         input.Password,
		TotalPostLike:    0,
		TotalChatMessage: 0,
	}

	createdAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.CreateAccount(account)
	if err != nil {
		return nil, err
	}

	result := &model.Account{
		ID:               createdAccount.ID.String(),
		Name:             createdAccount.Name,
		Email:            createdAccount.Email,
		Password:         createdAccount.Password,
		TotalPostLike:    createdAccount.TotalPostLike,
		TotalChatMessage: createdAccount.TotalChatMessage,
	}

	return result, nil
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, id string, input model.AccountInput) (*model.Account, error) {
	convertedId, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountById(convertedId)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	foundAccount.Name = input.Name
	foundAccount.Email = input.Email
	foundAccount.Password = input.Password
	updatedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.UpdateAccountById(convertedId, foundAccount)
	if err != nil {
		return nil, err
	}

	result := &model.Account{
		ID:               updatedAccount.ID.String(),
		Name:             updatedAccount.Name,
		Email:            updatedAccount.Email,
		Password:         updatedAccount.Password,
		TotalPostLike:    updatedAccount.TotalPostLike,
		TotalChatMessage: updatedAccount.TotalChatMessage,
	}

	return result, nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, id string) (*model.Account, error) {
	convertedId, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountById(convertedId)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	deletedAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.DeleteAccountById(convertedId)
	if err != nil {
		return nil, err
	}

	result := &model.Account{
		ID:               deletedAccount.ID.String(),
		Name:             deletedAccount.Name,
		Email:            deletedAccount.Email,
		Password:         deletedAccount.Password,
		TotalPostLike:    deletedAccount.TotalPostLike,
		TotalChatMessage: deletedAccount.TotalChatMessage,
	}

	return result, nil
}

// Account is the resolver for the account field.
func (r *postResolver) Account(ctx context.Context, obj *model.Post, federationRequires map[string]any) (*model.Account, error) {
	accountId, ok := federationRequires["accountId"].(string)
	if !ok {
		return nil, fmt.Errorf("account id is required")
	}

	convertedId, err := uuid.Parse(accountId)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountById(convertedId)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	result := &model.Account{
		ID:               foundAccount.ID.String(),
		Name:             foundAccount.Name,
		Email:            foundAccount.Email,
		Password:         foundAccount.Password,
		TotalPostLike:    foundAccount.TotalPostLike,
		TotalChatMessage: foundAccount.TotalChatMessage,
	}

	return result, nil
}

// Account is the resolver for the account field.
func (r *postLikeResolver) Account(ctx context.Context, obj *model.PostLike, federationRequires map[string]any) (*model.Account, error) {
	accountId, ok := federationRequires["accountId"].(string)
	if !ok {
		return nil, fmt.Errorf("account id is required")
	}

	convertedId, err := uuid.Parse(accountId)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountById(convertedId)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	result := &model.Account{
		ID:               foundAccount.ID.String(),
		Name:             foundAccount.Name,
		Email:            foundAccount.Email,
		Password:         foundAccount.Password,
		TotalPostLike:    foundAccount.TotalPostLike,
		TotalChatMessage: foundAccount.TotalChatMessage,
	}

	return result, nil
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context) ([]*model.Account, error) {
	foundAccounts, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAllAccounts()
	if err != nil {
		return nil, err
	}

	var result []*model.Account
	for _, foundAccount := range foundAccounts {
		result = append(result, &model.Account{
			ID:               foundAccount.ID.String(),
			Name:             foundAccount.Name,
			Email:            foundAccount.Email,
			Password:         foundAccount.Password,
			TotalPostLike:    foundAccount.TotalPostLike,
			TotalChatMessage: foundAccount.TotalChatMessage,
		})
	}

	return result, nil
}

// Account is the resolver for the account field.
func (r *queryResolver) Account(ctx context.Context, id string) (*model.Account, error) {
	convertedId, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	foundAccount, err := r.RootContainer.UseCaseContainer.AccountUseCase.GetAccountById(convertedId)
	if err != nil {
		return nil, err
	}

	if foundAccount == nil {
		return nil, fmt.Errorf("account not found")
	}

	result := &model.Account{
		ID:               foundAccount.ID.String(),
		Name:             foundAccount.Name,
		Email:            foundAccount.Email,
		Password:         foundAccount.Password,
		TotalPostLike:    foundAccount.TotalPostLike,
		TotalChatMessage: foundAccount.TotalChatMessage,
	}

	return result, nil
}

// ChatMessage returns ChatMessageResolver implementation.
func (r *Resolver) ChatMessage() ChatMessageResolver { return &chatMessageResolver{r} }

// ChatRoomMember returns ChatRoomMemberResolver implementation.
func (r *Resolver) ChatRoomMember() ChatRoomMemberResolver { return &chatRoomMemberResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// PostLike returns PostLikeResolver implementation.
func (r *Resolver) PostLike() PostLikeResolver { return &postLikeResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type chatMessageResolver struct{ *Resolver }
type chatRoomMemberResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type postLikeResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
